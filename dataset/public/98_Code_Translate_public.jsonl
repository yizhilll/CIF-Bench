{"Input": "def numDecodings( s):\n        n = len(s)\n        f = [1] + [0] * n\n        for i in range(1, n + 1):\n            if s[i - 1] != '0':\n                f[i] += f[i - 1]\n            if i > 1 and s[i - 2] != '0' and int(s[i-2:i]) <= 26:\n                f[i] += f[i - 2]\n        return f[n]", "Output": "int numDecodings(string s) {\n        int n = s.size();\n        vector<int> f(n + 1);\n        f[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            if (s[i - 1] != '0') {\n                f[i] += f[i - 1];\n            }\n            if (i > 1 && s[i - 2] != '0' && ((s[i - 2] - '0') * 10 + (s[i - 1] - '0') <= 26)) {\n                f[i] += f[i - 2];\n            }\n        }\n        return f[n];\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def square(x):\n    return x*x\nprint(square(5))", "Output": "#include <iostream>\nusing namespace std;\nint square(int x){\n    return x*x;\n}\nint main(){\n    cout << square(5) << endl;\n    return 0;\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "num = int(input())\nif num % 2 == 0:\n    print(num, 'is even')\nelse:\n    print(num, 'is odd')", "Output": "int num;\nif(num%2 == 0){\n\tstd::cout << num << \" is even\";\n}else{\n\tstd::cout << num << \" is odd\";\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "x = 5\nif x < 10:\n    print('x is less than 10')\nelse:\n    print('x is greater than or equal to 10')", "Output": "int x = 5;\nif (x < 10) {\n\tcout << \"x is less than 10\" << endl;\n} \nelse {\n\tcout << \"x is greater than or equal to 10\" << endl;\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def sortColors(nums):\n        n = len(nums)\n        ptr = 0\n        for i in range(n):\n            if nums[i] == 0:\n                nums[i], nums[ptr] = nums[ptr], nums[i]\n                ptr += 1\n        for i in range(ptr, n):\n            if nums[i] == 1:\n                nums[i], nums[ptr] = nums[ptr], nums[i]\n                ptr += 1", "Output": "void sortColors(vector<int>& nums) {\n        int n = nums.size();\n        int ptr = 0;\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) {\n                swap(nums[i], nums[ptr]);\n                ++ptr;\n            }\n        }\n        for (int i = ptr; i < n; ++i) {\n            if (nums[i] == 1) {\n                swap(nums[i], nums[ptr]);\n                ++ptr;\n            }\n        }\n    }\n", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def grayCode(n):\n        ans = [0]\n        for i in range(1, n + 1):\n            for j in range(len(ans) - 1, -1, -1):\n                ans.append(ans[j] | (1 << (i - 1)))\n        return ans", "Output": "vector<int> grayCode(int n) {\n        vector<int> ret;\n        ret.reserve(1 << n);\n        ret.push_back(0);\n        for (int i = 1; i <= n; i++) {\n            int m = ret.size();\n            for (int j = m - 1; j >= 0; j--) {\n                ret.push_back(ret[j] | (1 << (i - 1)));\n            }\n        }\n        return ret;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def flatten(root):\n        if not root:\n            return\n        \n        stack = [root]\n        prev = None\n        \n        while stack:\n            curr = stack.pop()\n            if prev:\n                prev.left = None\n                prev.right = curr\n            left, right = curr.left, curr.right\n            if right:\n                stack.append(right)\n            if left:\n                stack.append(left)\n            prev = curr", "Output": "void flatten(TreeNode* root) {\n        if (root == nullptr) {\n            return;\n        }\n        auto stk = stack<TreeNode*>();\n        stk.push(root);\n        TreeNode *prev = nullptr;\n        while (!stk.empty()) {\n            TreeNode *curr = stk.top(); stk.pop();\n            if (prev != nullptr) {\n                prev->left = nullptr;\n                prev->right = curr;\n            }\n            TreeNode *left = curr->left, *right = curr->right;\n            if (right != nullptr) {\n                stk.push(right);\n            }\n            if (left != nullptr) {\n                stk.push(left);\n            }\n            prev = curr;\n        }\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "x = input()\nif x.isdigit():\n    x = int(x)\n    if x % 2 == 0:\n        print('Even')\n    else:\n        print('Odd')\nelse:\n    print('Input is not a number')", "Output": "#include <iostream>\n#include <string>\n#include <ctype.h>\nusing namespace std;\n\n\nint main() {\n    char x;\n    cin >> x;\n\tif (isdigit(x)) {\n\t\tif (x % 2 == 0) {\n\t\t\tcout << \"Even\" << endl;\n\t\t} else {\n\t\t\tcout << \"Odd\" << endl;\n\t\t}\n\t} else {\n\t\tcout << \"Input is not a number\" << endl;\n\t}\n\treturn 0;\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def solve( board):\n        if not board:\n            return\n        \n        n, m = len(board), len(board[0])\n        que = collections.deque()\n        for i in range(n):\n            if board[i][0] == \"O\":\n                que.append((i, 0))\n                board[i][0] = \"A\"\n            if board[i][m - 1] == \"O\":\n                que.append((i, m - 1))\n                board[i][m - 1] = \"A\"\n        for i in range(m - 1):\n            if board[0][i] == \"O\":\n                que.append((0, i))\n                board[0][i] = \"A\"\n            if board[n - 1][i] == \"O\":\n                que.append((n - 1, i))\n                board[n - 1][i] = \"A\"\n        \n        while que:\n            x, y = que.popleft()\n            for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:\n                if 0 <= mx < n and 0 <= my < m and board[mx][my] == \"O\":\n                    que.append((mx, my))\n                    board[mx][my] = \"A\"\n        \n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == \"A\":\n                    board[i][j] = \"O\"\n                elif board[i][j] == \"O\":\n                    board[i][j] = \"X\"", "Output": "const int dx[4] = {1, -1, 0, 0};\n    const int dy[4] = {0, 0, 1, -1};\n\n    void solve(vector<vector<char>>& board) {\n        int n = board.size();\n        if (n == 0) {\n            return;\n        }\n        int m = board[0].size();\n        queue<pair<int, int>> que;\n        for (int i = 0; i < n; i++) {\n            if (board[i][0] == 'O') {\n                que.emplace(i, 0);\n                board[i][0] = 'A';\n            }\n            if (board[i][m - 1] == 'O') {\n                que.emplace(i, m - 1);\n                board[i][m - 1] = 'A';\n            }\n        }\n        for (int i = 1; i < m - 1; i++) {\n            if (board[0][i] == 'O') {\n                que.emplace(0, i);\n                board[0][i] = 'A';\n            }\n            if (board[n - 1][i] == 'O') {\n                que.emplace(n - 1, i);\n                board[n - 1][i] = 'A';\n            }\n        }\n        while (!que.empty()) {\n            int x = que.front().first, y = que.front().second;\n            que.pop();\n            for (int i = 0; i < 4; i++) {\n                int mx = x + dx[i], my = y + dy[i];\n                if (mx < 0 || my < 0 || mx >= n || my >= m || board[mx][my] != 'O') {\n                    continue;\n                }\n                que.emplace(mx, my);\n                board[mx][my] = 'A';\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (board[i][j] == 'A') {\n                    board[i][j] = 'O';\n                } else if (board[i][j] == 'O') {\n                    board[i][j] = 'X';\n                }\n            }\n        }\n    }\n\n", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "class MedianFinder:\n\n    def __init__(self):\n        self.queMin = list()\n        self.queMax = list()\n\n    def addNum(self, num: int) -> None:\n        queMin_ = self.queMin\n        queMax_ = self.queMax\n\n        if not queMin_ or num <= -queMin_[0]:\n            heapq.heappush(queMin_, -num)\n            if len(queMax_) + 1 < len(queMin_):\n                heapq.heappush(queMax_, -heapq.heappop(queMin_))\n        else:\n            heapq.heappush(queMax_, num)\n            if len(queMax_) > len(queMin_):\n                heapq.heappush(queMin_, -heapq.heappop(queMax_))\n        \n    def findMedian(self) -> float:\n        queMin_ = self.queMin\n        queMax_ = self.queMax\n\n        if len(queMin_) > len(queMax_):\n            return -queMin_[0]\n        return (-queMin_[0] + queMax_[0]) / 2", "Output": "class MedianFinder {\npublic:\n    priority_queue<int, vector<int>, less<int>> queMin;\n    priority_queue<int, vector<int>, greater<int>> queMax;\n\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (queMin.empty() || num <= queMin.top()) {\n            queMin.push(num);\n            if (queMax.size() + 1 < queMin.size()) {\n                queMax.push(queMin.top());\n                queMin.pop();\n            }\n        } else {\n            queMax.push(num);\n            if (queMax.size() > queMin.size()) {\n                queMin.push(queMax.top());\n                queMax.pop();\n            }\n        }\n    }\n\n    double findMedian() {\n        if (queMin.size() > queMax.size()) {\n            return queMin.top();\n        }\n        return (queMin.top() + queMax.top()) / 2.0;\n    }\n};", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def buildTree(preorder, inorder):\n        if not preorder:\n            return None\n\n        root = TreeNode(preorder[0])\n        stack = [root]\n        inorderIndex = 0\n        for i in range(1, len(preorder)):\n            preorderVal = preorder[i]\n            node = stack[-1]\n            if node.val != inorder[inorderIndex]:\n                node.left = TreeNode(preorderVal)\n                stack.append(node.left)\n            else:\n                while stack and stack[-1].val == inorder[inorderIndex]:\n                    node = stack.pop()\n                    inorderIndex += 1\n                node.right = TreeNode(preorderVal)\n                stack.append(node.right)\n\n        return root", "Output": "TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        if (!preorder.size()) {\n            return nullptr;\n        }\n        TreeNode* root = new TreeNode(preorder[0]);\n        stack<TreeNode*> stk;\n        stk.push(root);\n        int inorderIndex = 0;\n        for (int i = 1; i < preorder.size(); ++i) {\n            int preorderVal = preorder[i];\n            TreeNode* node = stk.top();\n            if (node->val != inorder[inorderIndex]) {\n                node->left = new TreeNode(preorderVal);\n                stk.push(node->left);\n            }\n            else {\n                while (!stk.empty() && stk.top()->val == inorder[inorderIndex]) {\n                    node = stk.top();\n                    stk.pop();\n                    ++inorderIndex;\n                }\n                node->right = new TreeNode(preorderVal);\n                stk.push(node->right);\n            }\n        }\n        return root;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "str = input()\nstr_lower = str.lower()\nprint(str_lower)", "Output": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nint main(){\n    string str;\n    cin >> str;\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    cout << str;\n    return 0;\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "a = 1\nif a == 1:\n    print('Hello World!')", "Output": "int a = 1;\nif (a == 1) {\n    cout << \"Hello World!\" << endl;\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "a = 5\nb = 10\ntmp = a\na = b\nb = tmp\nprint(a,b)", "Output": "#include<iostream>\nusing namespace std;\nint main(){\n    int a=5;\n    int b=10;\n    int tmp=a;\n    a=b;\n    b=tmp;\n    cout<<a<<\" \"<<b<<endl;\n    return 0;\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def minimumOperations(leaves):\n        n = len(leaves)\n        g = (1 if leaves[0] == \"y\" else -1)\n        gmin = g\n        ans = float(\"inf\")\n\n        for i in range(1, n):\n            isYellow = int(leaves[i] == \"y\")\n            g += 2 * isYellow - 1\n            if i != n - 1:\n                ans = min(ans, gmin - g)\n            gmin = min(gmin, g)\n        return ans + (g + n) // 2", "Output": "int minimumOperations(string leaves) {\n        int n = leaves.size();\n        int g = (leaves[0] == 'y' ? 1 : -1);\n        int gmin = g;\n        int ans = INT_MAX;\n        for (int i = 1; i < n; ++i) {\n            int isYellow = (leaves[i] == 'y');\n            g += 2 * isYellow - 1;\n            if (i != n - 1) {\n                ans = min(ans, gmin - g);\n            }\n            gmin = min(gmin, g);\n        }\n        return ans + (g + n) / 2;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "a = [1, 2, 3]\nprint(sum(a))", "Output": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\n    vector<unsigned int> a{1,2,3};\n    int sum=0;\n    for(int i=0;i<a.size();++i){\n        sum+=a[i];\n    }\n    cout<<sum;\n    return 0;\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def reorderList(head):\n        if not head:\n            return\n        \n        mid = self.middleNode(head)\n        l1 = head\n        l2 = mid.next\n        mid.next = None\n        l2 = self.reverseList(l2)\n        self.mergeList(l1, l2)\n    \n    def middleNode(head):\n        slow = fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n    \n    def reverseList(head):\n        prev = None\n        curr = head\n        while curr:\n            nextTemp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nextTemp\n        return prev\n\n    def mergeList(l1, l2):\n        while l1 and l2:\n            l1_tmp = l1.next\n            l2_tmp = l2.next\n\n            l1.next = l2\n            l1 = l1_tmp\n\n            l2.next = l1\n            l2 = l2_tmp\n", "Output": "void reorderList(ListNode* head) {\n        if (head == nullptr) {\n            return;\n        }\n        ListNode* mid = middleNode(head);\n        ListNode* l1 = head;\n        ListNode* l2 = mid->next;\n        mid->next = nullptr;\n        l2 = reverseList(l2);\n        mergeList(l1, l2);\n    }\n\n    ListNode* middleNode(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast->next != nullptr && fast->next->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr != nullptr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n\n    void mergeList(ListNode* l1, ListNode* l2) {\n        ListNode* l1_tmp;\n        ListNode* l2_tmp;\n        while (l1 != nullptr && l2 != nullptr) {\n            l1_tmp = l1->next;\n            l2_tmp = l2->next;\n\n            l1->next = l2;\n            l1 = l1_tmp;\n\n            l2->next = l1;\n            l2 = l2_tmp;\n        }\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def pathSum(root, targetSum):\n        ret = list()\n        parent = collections.defaultdict(lambda: None)\n\n        def getPath(node):\n            tmp = list()\n            while node:\n                tmp.append(node.val)\n                node = parent[node]\n            ret.append(tmp[::-1])\n\n        if not root:\n            return ret\n        \n        que_node = collections.deque([root])\n        que_total = collections.deque([0])\n\n        while que_node:\n            node = que_node.popleft()\n            rec = que_total.popleft() + node.val\n\n            if not node.left and not node.right:\n                if rec == targetSum:\n                    getPath(node)\n            else:\n                if node.left:\n                    parent[node.left] = node\n                    que_node.append(node.left)\n                    que_total.append(rec)\n                if node.right:\n                    parent[node.right] = node\n                    que_node.append(node.right)\n                    que_total.append(rec)\n\n        return ret", "Output": "vector<vector<int>> ret;\n    unordered_map<TreeNode*, TreeNode*> parent;\n\n    void getPath(TreeNode* node) {\n        vector<int> tmp;\n        while (node != nullptr) {\n            tmp.emplace_back(node->val);\n            node = parent[node];\n        }\n        reverse(tmp.begin(), tmp.end());\n        ret.emplace_back(tmp);\n    }\n\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        if (root == nullptr) {\n            return ret;\n        }\n\n        queue<TreeNode*> que_node;\n        queue<int> que_sum;\n        que_node.emplace(root);\n        que_sum.emplace(0);\n\n        while (!que_node.empty()) {\n            TreeNode* node = que_node.front();\n            que_node.pop();\n            int rec = que_sum.front() + node->val;\n            que_sum.pop();\n\n            if (node->left == nullptr && node->right == nullptr) {\n                if (rec == targetSum) {\n                    getPath(node);\n                }\n            } else {\n                if (node->left != nullptr) {\n                    parent[node->left] = node;\n                    que_node.emplace(node->left);\n                    que_sum.emplace(rec);\n                }\n                if (node->right != nullptr) {\n                    parent[node->right] = node;\n                    que_node.emplace(node->right);\n                    que_sum.emplace(rec);\n                }\n            }\n        }\n\n        return ret;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "class Solution:\n    def dicesProbability(self, n: int) -> List[float]:\n        dp = [1 / 6] * 6\n        for i in range(2, n + 1):\n            tmp = [0] * (5 * i + 1)\n            for j in range(len(dp)):\n                for k in range(6):\n                    tmp[j + k] += dp[j] / 6\n            dp = tmp\n        return dp", "Output": "class Solution {\npublic:\n    vector<double> dicesProbability(int n) {\n        vector<double> dp(6, 1.0 / 6.0);\n        for (int i = 2; i <= n; i++) {\n            vector<double> tmp(5 * i + 1, 0);\n            for (int j = 0; j < dp.size(); j++) {\n                for (int k = 0; k < 6; k++) {\n                    tmp[j + k] += dp[j] / 6.0;\n                }\n            }\n            dp = tmp;\n        }\n        return dp;\n    }\n};", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def search(nums, target):\n        if not nums:\n            return False\n        \n        n = len(nums)\n        if n == 1:\n            return nums[0] == target\n        \n        l, r = 0, n - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return True\n            if nums[l] == nums[mid] and nums[mid] == nums[r]:\n                l += 1\n                r -= 1\n            elif nums[l] <= nums[mid]:\n                if nums[l] <= target and target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target and target <= nums[n - 1]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        \n        return False", "Output": "bool search(vector<int> &nums, int target) {\n        int n = nums.size();\n        if (n == 0) {\n            return false;\n        }\n        if (n == 1) {\n            return nums[0] == target;\n        }\n        int l = 0, r = n - 1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (nums[mid] == target) {\n                return true;\n            }\n            if (nums[l] == nums[mid] && nums[mid] == nums[r]) {\n                ++l;\n                --r;\n            } else if (nums[l] <= nums[mid]) {\n                if (nums[l] <= target && target < nums[mid]) {\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[n - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n        return false;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def plusOne(digits):\n        n = len(digits)\n        for i in range(n - 1, -1, -1):\n            if digits[i] != 9:\n                digits[i] += 1\n                for j in range(i + 1, n):\n                    digits[j] = 0\n                return digits\n        return [1] + [0] * n", "Output": "vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size();\n        for (int i = n - 1; i >= 0; --i) {\n            if (digits[i] != 9) {\n                ++digits[i];\n                for (int j = i + 1; j < n; ++j) {\n                    digits[j] = 0;\n                }\n                return digits;\n            }\n        }\n        vector<int> ans(n + 1);\n        ans[0] = 1;\n        return ans;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def maxDepth(root):\n        return max((maxDepth(child) for child in root.children), default=0) + 1 if root else 0", "Output": "int maxDepth(Node* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        int maxChildDepth = 0;\n        vector<Node *> children = root->children;\n        for (auto child : children) {\n            int childDepth = maxDepth(child);\n            maxChildDepth = max(maxChildDepth, childDepth);\n        }\n        return maxChildDepth + 1;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def storeWater(bucket, vat):\n        n = len(bucket)\n        pq = []\n        cnt = 0\n        for i in range(n):\n            if bucket[i] == 0 and vat[i]:\n                cnt += 1\n                bucket[i] += 1\n            if vat[i] > 0:\n                heapq.heappush(pq, [-((vat[i] + bucket[i] - 1) // bucket[i]), i])\n        if not pq:\n            return 0\n        res = float('inf')\n        while cnt < res:\n            v, i = heapq.heappop(pq)\n            v = -v\n            res = min(res, cnt + v)\n            if v == 1:\n                break\n            t = (vat[i] + v - 2) // (v - 1)\n            cnt += t - bucket[i]\n            bucket[i] = t\n            heapq.heappush(pq, [-((vat[i] + bucket[i] - 1) // bucket[i]), i])\n        return res", "Output": "int storeWater(vector<int>& bucket, vector<int>& vat) {\n        int n = bucket.size();\n        priority_queue<pair<int, int>> q;\n        int cnt = 0;\n        for (int i = 0; i < n; ++i) {\n            if (bucket[i] == 0 && vat[i]) {\n                ++cnt;\n                ++bucket[i];\n            }\n            if (vat[i] > 0) {\n                q.emplace((vat[i] + bucket[i] - 1) / bucket[i], i);\n            }\n        }\n        if (q.empty()) {\n            return 0;\n        }\n        int res = INT_MAX;\n        while (cnt < res) {\n            auto [v, i] = q.top();\n            res = min(res, cnt + v);\n            if (v == 1) {\n                break;\n            }\n            q.pop();\n            int t = (vat[i] + v - 2) / (v - 1);\n            cnt += t - bucket[i];\n            bucket[i] = t;\n            q.emplace((vat[i] + bucket[i] - 1) / bucket[i], i);\n        }\n        return res;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def missingNumber(nums):\n        n = len(nums)\n        total = n * (n + 1) // 2\n        arrSum = sum(nums)\n        return total - arrSum", "Output": "int missingNumber(vector<int>& nums) {\n        int n = nums.size();\n        int total = n * (n + 1) / 2;\n        int arrSum = 0;\n        for (int i = 0; i < n; i++) {\n            arrSum += nums[i];\n        }\n        return total - arrSum;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "class Solution:\n    def lastRemaining(self, n: int, m: int) -> int:\n        f = 0\n        for i in range(2, n + 1):\n            f = (m + f) % i\n        return f", "Output": "class Solution {\npublic:\n    int lastRemaining(int n, int m) {\n        int f = 0;\n        for (int i = 2; i != n + 1; ++i) {\n            f = (m + f) % i;\n        }\n        return f;\n    }\n};", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "class Solution:\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        ancestor = root\n        while True:\n            if p.val < ancestor.val and q.val < ancestor.val:\n                ancestor = ancestor.left\n            elif p.val > ancestor.val and q.val > ancestor.val:\n                ancestor = ancestor.right\n            else:\n                break\n        return ancestor\n", "Output": "class Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        TreeNode* ancestor = root;\n        while (true) {\n            if (p->val < ancestor->val && q->val < ancestor->val) {\n                ancestor = ancestor->left;\n            }\n            else if (p->val > ancestor->val && q->val > ancestor->val) {\n                ancestor = ancestor->right;\n            }\n            else {\n                break;\n            }\n        }\n        return ancestor;\n    }\n};", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def singleNumber(nums):\n        freq = collections.Counter(nums)\n        ans = [num for num, occ in freq.items() if occ == 1][0]\n        return ans", "Output": "int singleNumber(vector<int>& nums) {\n        unordered_map<int, int> freq;\n        for (int num: nums) {\n            ++freq[num];\n        }\n        int ans = 0;\n        for (auto [num, occ]: freq) {\n            if (occ == 1) {\n                ans = num;\n                break;\n            }\n        }\n        return ans;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def count_vowels(s):\n    vowels = 'aeiou'\n    count = 0\n    for c in s:\n        if c in vowels:\n            count += 1\n    return count", "Output": "int count_vowels(string s){\n\tstring vowels = \"aeiou\";\n\tint count = 0;\n\tfor(char c:s){\n\t\tif(vowels.find(c) != string::npos){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def singleNumber(nums):\n        ans = 0\n        for i in range(32):\n            total = sum((num >> i) & 1 for num in nums)\n            if total % 3:\n                if i == 31:\n                    ans -= (1 << i)\n                else:\n                    ans |= (1 << i)\n        return ans", "Output": "int singleNumber(vector<int>& nums) {\n        int ans = 0;\n        for (int i = 0; i < 32; ++i) {\n            int total = 0;\n            for (int num: nums) {\n                total += ((num >> i) & 1);\n            }\n            if (total % 3) {\n                ans |= (1 << i);\n            }\n        }\n        return ans;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "num_list = [1, 2, 3, 4]\nsum = 0\nfor num in num_list:\n    sum += num\nprint(sum)", "Output": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(){\n    vector<int> num_list = {1, 2, 3, 4};\n    int sum = 0;\n    for (int num: num_list){\n        sum += num;\n    }\n    cout << sum << endl;\n    return 0;\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def reorderList(head):\n        if not head:\n            return\n        \n        vec = list()\n        node = head\n        while node:\n            vec.append(node)\n            node = node.next\n        \n        i, j = 0, len(vec) - 1\n        while i < j:\n            vec[i].next = vec[j]\n            i += 1\n            if i == j:\n                break\n            vec[j].next = vec[i]\n            j -= 1\n        \n        vec[i].next = None", "Output": "void reorderList(ListNode *head) {\n        if (head == nullptr) {\n            return;\n        }\n        vector<ListNode *> vec;\n        ListNode *node = head;\n        while (node != nullptr) {\n            vec.emplace_back(node);\n            node = node->next;\n        }\n        int i = 0, j = vec.size() - 1;\n        while (i < j) {\n            vec[i]->next = vec[j];\n            i++;\n            if (i == j) {\n                break;\n            }\n            vec[j]->next = vec[i];\n            j--;\n        }\n        vec[i]->next = nullptr;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "x = 5\nif x < 10:\n    print('Hello')\nelse:\n    print('Goodbye')", "Output": "#include <iostream>\nusing namespace std;\nint main() {\n    int x = 5;\n    if (x < 10) {\n        cout << 'Hello' << endl;\n    } else {\n        cout << 'Goodbye' << endl;\n    }\n    return 0;\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "x = 2\nif x > 1:\n    print('x大于1')\nelse:\n    print('x小于等于1')", "Output": "int x = 2;\nif (x > 1) {\n    cout << 'x大于1';\n} else {\n    cout << 'x小于等于1';\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def lengthOfLongestSubstring(str):\n    occ = set()\n    n = len(s)\n    rk, ans = -1, 0\n    for i in range(n):\n        if i != 0:\n            occ.remove(s[i - 1])\n        while rk + 1 < n and s[rk + 1] not in occ:\n            occ.add(s[rk + 1])\n            rk += 1\n        ans = max(ans, rk - i + 1)\n    return ans", "Output": "int lengthOfLongestSubstring(string s) {\n        unordered_set<char> occ;\n        int n = s.size();\n        int rk = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i != 0) {\n                occ.erase(s[i - 1]);\n            }\n            while (rk + 1 < n && !occ.count(s[rk + 1])) {\n                occ.insert(s[rk + 1]);\n                ++rk;\n            }\n            ans = max(ans, rk - i + 1);\n        }\n        return ans;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def isValidBST(root):\n        def helper(node, lower = float('-inf'), upper = float('inf')):\n            if not node:\n                return True\n            \n            val = node.val\n            if val <= lower or val >= upper:\n                return False\n\n            if not helper(node.right, val, upper):\n                return False\n            if not helper(node.left, lower, val):\n                return False\n            return True\n\n        return helper(root)", "Output": "bool helper(TreeNode* root, long long lower, long long upper) {\n        if (root == nullptr) {\n            return true;\n        }\n        if (root -> val <= lower || root -> val >= upper) {\n            return false;\n        }\n        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);\n    }\n    bool isValidBST(TreeNode* root) {\n        return helper(root, LONG_MIN, LONG_MAX);\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        a = b = 0\n        for num in nums:\n            a, b = (~a & b & num) | (a & ~b & ~num), ~a & (b ^ num)\n        return b\n", "Output": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int a = 0, b = 0;\n        for (int num: nums) {\n            tie(a, b) = pair{(~a & b & num) | (a & ~b & ~num), ~a & (b ^ num)};\n        }\n        return b;\n    }\n};", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def sumNumbers(root):\n        def dfs(root, prevTotal):\n            if not root:\n                return 0\n            total = prevTotal * 10 + root.val\n            if not root.left and not root.right:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n\n        return dfs(root, 0)", "Output": "int dfs(TreeNode* root, int prevSum) {\n        if (root == nullptr) {\n            return 0;\n        }\n        int sum = prevSum * 10 + root->val;\n        if (root->left == nullptr && root->right == nullptr) {\n            return sum;\n        } else {\n            return dfs(root->left, sum) + dfs(root->right, sum);\n        }\n    }\n    int sumNumbers(TreeNode* root) {\n        return dfs(root, 0);\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def storeWater(bucket, vat):\n        mx = max(vat)\n        if mx == 0:\n            return 0\n        ans = inf\n        for x in range(1, mx + 1):\n            y = sum(max(0, (v + x - 1) // x - b) for v, b in zip(vat, bucket))\n            ans = min(ans, x + y)\n        return ans", "Output": "int storeWater(vector<int>& bucket, vector<int>& vat) {\n        int mx = *max_element(vat.begin(), vat.end());\n        if (mx == 0) {\n            return 0;\n        }\n        int ans = 1 << 30;\n        int n = bucket.size();\n        for (int x = 1; x <= mx; ++x) {\n            int y = 0;\n            for (int i = 0; i < n; ++i) {\n                y += max(0, (vat[i] + x - 1) / x - bucket[i]);\n            }\n            ans = min(ans, x + y);\n        }\n        return ans;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def deleteDuplicates(head):\n        if not head:\n            return head\n\n        cur = head\n        while cur.next:\n            if cur.val == cur.next.val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n\n        return head", "Output": "ListNode* deleteDuplicates(ListNode* head) {\n        if (!head) {\n            return head;\n        }\n\n        ListNode* cur = head;\n        while (cur->next) {\n            if (cur->val == cur->next->val) {\n                cur->next = cur->next->next;\n            }\n            else {\n                cur = cur->next;\n            }\n        }\n\n        return head;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def numTrees(n):\n        G = [0]*(n+1)\n        G[0], G[1] = 1, 1\n\n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                G[i] += G[j-1] * G[i-j]\n\n        return G[n]", "Output": "int numTrees(int n) {\n        vector<int> G(n + 1, 0);\n        G[0] = 1;\n        G[1] = 1;\n\n        for (int i = 2; i <= n; ++i) {\n            for (int j = 1; j <= i; ++j) {\n                G[i] += G[j - 1] * G[i - j];\n            }\n        }\n        return G[n];\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        bits = [0]\n        for i in range(1, n + 1):\n            bits.append(bits[i & (i - 1)] + 1)\n        return bits\n", "Output": "class Solution {\npublic:\n    vector<int> countBits(int n) {\n        vector<int> bits(n + 1);\n        for (int i = 1; i <= n; i++) {\n            bits[i] = bits[i & (i - 1)] + 1;\n        }\n        return bits;\n    }\n};", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def matrixReshape(nums, r, c):\n        m, n = len(nums), len(nums[0])\n        if m * n != r * c:\n            return nums\n        \n        ans = [[0] * c for _ in range(r)]\n        for x in range(m * n):\n            ans[x // c][x % c] = nums[x // n][x % n]\n        \n        return ans", "Output": "vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\n        int m = nums.size();\n        int n = nums[0].size();\n        if (m * n != r * c) {\n            return nums;\n        }\n\n        vector<vector<int>> ans(r, vector<int>(c));\n        for (int x = 0; x < m * n; ++x) {\n            ans[x / c][x % c] = nums[x / n][x % n];\n        }\n        return ans;\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def checkRecord(s):\n        absents = lates = 0\n        for i, c in enumerate(s):\n            if c == \"A\":\n                absents += 1\n                if absents >= 2:\n                    return False\n            if c == \"L\":\n                lates += 1\n                if lates >= 3:\n                    return False\n            else:\n                lates = 0\n        \n        return True", "Output": "bool checkRecord(string s) {\n        int absents = 0, lates = 0;\n        for (auto &ch : s) {\n            if (ch == 'A') {\n                absents++;\n                if (absents >= 2) {\n                    return false;\n                }\n            }\n            if (ch == 'L') {\n                lates++;\n                if (lates >= 3) {\n                    return false;\n                }\n            } else {\n                lates = 0;\n            }\n        }\n        return true;\n    }\n", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "class Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        word2ch = dict()\n        ch2word = dict()\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        for ch, word in zip(pattern, words):\n            if (word in word2ch and word2ch[word] != ch) or (ch in ch2word and ch2word[ch] != word):\n                return False\n            word2ch[word] = ch\n            ch2word[ch] = word\n    \n        return True", "Output": "class Solution {\npublic:\n    bool wordPattern(string pattern, string str) {\n        unordered_map<string, char> str2ch;\n        unordered_map<char, string> ch2str;\n        int m = str.length();\n        int i = 0;\n        for (auto ch : pattern) {\n            if (i >= m) {\n                return false;\n            }\n            int j = i;\n            while (j < m && str[j] != ' ') j++;\n            const string &tmp = str.substr(i, j - i);\n            if (str2ch.count(tmp) && str2ch[tmp] != ch) {\n                return false;\n            }\n            if (ch2str.count(ch) && ch2str[ch] != tmp) {\n                return false;\n            }\n            str2ch[tmp] = ch;\n            ch2str[ch] = tmp;\n            i = j + 1;\n        }\n        return i >= m;\n    }\n};", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def twoSum(nums, target):\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n        \n        return []", "Output": "vector<int> twoSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n        return {};\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def square(x):\n    return x*x", "Output": "int square(int x){\n    return x*x;\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, num):\n        if num % i == 0:\n            return False\n    return True", "Output": "bool is_prime(int num){\n    if(num < 2){\n        return false;\n    }\n    for(int i=2;i<num;i++){\n        if(num%i==0){\n            return false;\n        }\n    }\n    return true;\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def minimumOperations(leaves):\n        n = len(leaves)\n        f = [[0, 0, 0] for _ in range(n)]\n        f[0][0] = int(leaves[0] == \"y\")\n        f[0][1] = f[0][2] = f[1][2] = float(\"inf\")\n\n        for i in range(1, n):\n            isRed = int(leaves[i] == \"r\")\n            isYellow = int(leaves[i] == \"y\")\n            f[i][0] = f[i - 1][0] + isYellow\n            f[i][1] = min(f[i - 1][0], f[i - 1][1]) + isRed\n            if i >= 2:\n                f[i][2] = min(f[i - 1][1], f[i - 1][2]) + isYellow\n        \n        return f[n - 1][2]", "Output": "int minimumOperations(string leaves) {\n        int n = leaves.size();\n        vector<vector<int>> f(n, vector<int>(3));\n        f[0][0] = (leaves[0] == 'y');\n        f[0][1] = f[0][2] = f[1][2] = INT_MAX;\n        for (int i = 1; i < n; ++i) {\n            int isRed = (leaves[i] == 'r');\n            int isYellow = (leaves[i] == 'y');\n            f[i][0] = f[i - 1][0] + isYellow;\n            f[i][1] = min(f[i - 1][0], f[i - 1][1]) + isRed;\n            if (i >= 2) {\n                f[i][2] = min(f[i - 1][1], f[i - 1][2]) + isYellow;\n            }\n        }\n        return f[n - 1][2];\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "import math\ndef calculate_distance(x1, y1, x2, y2):\n    distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    return distance\nprint(calculate_distance(0, 0, 3, 4))", "Output": "#include <iostream>\n#include <cmath>\n\t\nusing namespace std;\n\ndouble calculate_distance(int x1, int y1, int x2, int y2) {\n\tdouble distance = sqrt(pow((x2 - x1), 2) + pow((y2 - y1), 2));\n\treturn distance;\n}\nint main() {\n\tcout << calculate_distance(0, 0, 3, 4) << endl;\n\treturn 0;\n}", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
{"Input": "def sortedListToBST(head):\n        def getMedian(left, right):\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left, right):\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)", "Output": "ListNode* getMedian(ListNode* left, ListNode* right) {\n        ListNode* fast = left;\n        ListNode* slow = left;\n        while (fast != right && fast->next != right) {\n            fast = fast->next;\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n\n    TreeNode* buildTree(ListNode* left, ListNode* right) {\n        if (left == right) {\n            return nullptr;\n        }\n        ListNode* mid = getMedian(left, right);\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = buildTree(left, mid);\n        root->right = buildTree(mid->next, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        return buildTree(head, nullptr);\n    }", "Instruction": "在这个任务中，你会得到一个Python代码，你需要将这段代码转换成具有相同功能的C++函数。"}
